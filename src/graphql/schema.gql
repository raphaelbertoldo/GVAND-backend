directive @constraint(
  min: Int
  max: Int
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# @fulltext(indexes: [{ indexName: "MovieTitle", fields: ["title"] }])
type Movie {
  id: ID! @id(autogenerate: true)
  title: String!
  plot: String!
  poster: String!
  year: Int!
  runtime: Int!
  released: Date!
  countries: [String!]!
  languages: [String!]!
  actors: [Actor!]!
    @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
  director: Director!
    @relationship(type: "DIRECTED", direction: IN, properties: "Directed")
  genre: Genre!
    @relationship(type: "GENRE", direction: OUT, properties: "GenreName")

  similarMovies: [Movie!]!
    @cypher(
      statement: """
      MATCH (m:Movie)-[:GENRE]->(g:Genre)<-[:GENRE]-(s:Movie)
      RETURN s
      """
    )
}

type Actor {
  ActorId: ID! @id(autogenerate: true)
  name: String! @unique
  movies: [Movie!]!
    @relationship(type: "ACTED_IN", direction: OUT, properties: "ActedIn")
}

type Director {
  id: ID! @id(autogenerate: true)
  name: String! @unique
  movies: [Movie!]!
    @relationship(type: "DIRECTED", direction: OUT, properties: "Directed")
}

type Genre {
  id: ID! @id(autogenerate: true) @alias(property: "dbGenreId") ##Esse campo gera uma novo nome para o campo no banco de dados
  name: String! @unique
  movies: [Movie!]!
    @relationship(type: "GENRE", direction: IN, properties: "GenreName")
}

type User {
  userId: ID! @id(autogenerate: true)
  name: String!
  password: String!
  username: String! @unique
  rateds: [Movie!]!
    @relationship(type: "RATED", direction: OUT, properties: "Rating")
  recommendedMovies(username: String): [Movie!]!
    @cypher(
      statement: """
      MATCH (u:User)-[r:RATED]->(m:Movie)
      WHERE u.username = $username
      AND r.rating >= 4
      WITH collect(m) as likedMovies
      UNWIND likedMovies as likedMovie
      MATCH (likedMovie)-[:GENRE]->(g:Genre)<-[:GENRE]-(recommended:Movie)
      WHERE NOT recommended IN likedMovies
      RETURN recommended, count(*) as score
      ORDER BY score DESC
      LIMIT 10
      """
    )
}

interface ActedIn @relationshipProperties {
  role: String!
}

interface Directed @relationshipProperties {
  movie: String!
}

interface GenreName @relationshipProperties {
  genre: String!
}

interface Rating @relationshipProperties {
  rating: Float! @constraint(min: 0, max: 5)
  timestamp: DateTime! @timestamp(operations: [CREATE, UPDATE])
}

type Query {
  searchMovies(title: String!): [Movie]
    @cypher(
      statement: """
      CALL db.index.fulltext.queryNodes(\"titlesMovie\", $title) YIELD node RETURN node
      """
    )

  fuzzySearchMovies(title: String!): [Movie]
    @cypher(
      statement: """
       MATCH (m:Movie)
      WHERE m.title =~ '(?i).*' + $title + '.*'
       RETURN m
      """
    )
}

# CREATE FULLTEXT INDEX titlesMovie FOR (n:Movie) ON EACH [n.title, n.plot]  - Criar index

# CALL db.index.fulltext.queryNodes("titlesMovie", "param") YIELD node, score RETURN node.title, node.plot, score - Retornar filmes que cotem o 'param'
